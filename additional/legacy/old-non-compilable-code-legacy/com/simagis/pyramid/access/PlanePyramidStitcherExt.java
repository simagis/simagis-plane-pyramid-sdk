package com.simagis.pyramid.access;

import com.simagis.images.color.Image2D;
import com.simagis.images.color.ImageContext;
import com.simagis.pyramid.io.DefaultPlanePyramidIO;
import net.algart.contexts.*;
import net.algart.external.ImageConversions;
import com.simagis.images.color.SimpleColorImageFormatter;
import com.simagis.pyramid.standard.PlanePyramid;
import net.algart.simagis.pyramid.PlanePyramidSource;
import net.algart.arrays.*;
import net.algart.external.ExternalAlgorithmCaller;
import net.algart.external.MatrixToBufferedImageConverter;
import net.algart.math.IPoint;
import org.json.JSONException;
import org.json.JSONObject;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.logging.Logger;

public class PlanePyramidStitcherExt {
    private static final Logger LOGGER = Logger.getLogger(PlanePyramidStitcherExt.class.getName());

    public static PlanePyramidContainer stitch5Images(
        Context context,
        @Name("totalWidth") long totalWidth,
        @Name("totalHeight") long totalHeight,
        //[[Repeat() image1 ==> image$INDEX(start=2),,...(4)]]
        @Name("image1") Image2D image1,
        @Name("image1Left") @UI(description = "Pixel x-coordinate") long image1Left,
        @Name("image1Top") @UI(description = "Pixel y-coordinate") long image1Top,
        //[[Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! ]]
        @Name("image2") Image2D image2,
        @Name("image2Left") @UI(description = "Pixel x-coordinate") long image2Left,
        @Name("image2Top") @UI(description = "Pixel y-coordinate") long image2Top,
        @Name("image3") Image2D image3,
        @Name("image3Left") @UI(description = "Pixel x-coordinate") long image3Left,
        @Name("image3Top") @UI(description = "Pixel y-coordinate") long image3Top,
        @Name("image4") Image2D image4,
        @Name("image4Left") @UI(description = "Pixel x-coordinate") long image4Left,
        @Name("image4Top") @UI(description = "Pixel y-coordinate") long image4Top,
        @Name("image5") Image2D image5,
        @Name("image5Left") @UI(description = "Pixel x-coordinate") long image5Left,
        @Name("image5Top") @UI(description = "Pixel y-coordinate") long image5Top,
        //[[Repeat.AutoGeneratedEnd]]
        @Name("config") @UI(description = "Custom settings in JSON format", category = "text") String config,
        @Name("backgroundColor") @UI(defaultValue = "0,0,0", description = "Background color; "
            + "number of components defines the number of bands in the result") double[] backgroundColor)
        throws JSONException
    {
        Image2D instance = image1 != null ? image1
            //[[Repeat() image2 ==> image$INDEX(start=3),,...(3)]]
            : image2 != null ? image2
            //[[Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! ]]
            : image3 != null ? image3
            : image4 != null ? image4
            : image5 != null ? image5
            //[[Repeat.AutoGeneratedEnd]]
            : null;
        if (instance == null) {
            throw new NullPointerException("At least one image must be non-null");
        }
        JSONObject cfg = config == null ? new JSONObject() : new JSONObject(config);
        MemoryModel mm = context.as(ArrayMemoryContext.class).getMemoryModel(cfg.optString("memoryModel", ""));
        DefaultArrayContext arrayContext = new DefaultArrayContext(context);
        ArrayContext ac = arrayContext.part(0.0, 0.9);
        long t1 = System.nanoTime();
        PlanePyramid.AveragingCastMode averagingMode = PlanePyramid.AveragingCastMode.valueOf(
            cfg.optString("averagingCastMode", PlanePyramid.AveragingCastMode.NONE.name()));
        PlanePyramid pyramid = PlanePyramid.newInstance(mm,
            instance.i().elementType(),
            totalWidth, totalHeight,
            cfg.optInt("compression", PlanePyramid.DEFAULT_COMPRESSION),
            cfg.optInt("numberOfResolutions"),
            cfg.has("tileDim") ? new Dimension(cfg.getInt("tileDim"), cfg.getInt("tileDim")) : null,
            backgroundColor,
            averagingMode);
        DefaultPlanePyramidIO.setOptionsFromJSON(pyramid, cfg);
        long t2 = System.nanoTime();
        List<Matrix<? extends PArray>> matrices = new ArrayList<Matrix<? extends PArray>>();
        List<IPoint> offsets = new ArrayList<IPoint>();
        //[[Repeat() image1 ==> image$INDEX(start=2),,...(4)]]
        if (image1 != null) {
            matrices.add(ImageConversions.pack2DBandsIntoSequentialSamples(null, image1.rgbi()));
            offsets.add(IPoint.valueOf(image1Left, image1Top));
        }
        //[[Repeat.AutoGeneratedStart !! Auto-generated: NOT EDIT !! ]]
        if (image2 != null) {
            matrices.add(ImageConversions.pack2DBandsIntoSequentialSamples(null, image2.rgbi()));
            offsets.add(IPoint.valueOf(image2Left, image2Top));
        }
        if (image3 != null) {
            matrices.add(ImageConversions.pack2DBandsIntoSequentialSamples(null, image3.rgbi()));
            offsets.add(IPoint.valueOf(image3Left, image3Top));
        }
        if (image4 != null) {
            matrices.add(ImageConversions.pack2DBandsIntoSequentialSamples(null, image4.rgbi()));
            offsets.add(IPoint.valueOf(image4Left, image4Top));
        }
        if (image5 != null) {
            matrices.add(ImageConversions.pack2DBandsIntoSequentialSamples(null, image5.rgbi()));
            offsets.add(IPoint.valueOf(image5Left, image5Top));
        }
        //[[Repeat.AutoGeneratedEnd]]
        long t3 = System.nanoTime();
        int count = 0;
        double memory = 0.0;
        for (int i = 0; i < matrices.size(); i++) {
            ac.checkInterruptionAndUpdateProgress(matrices.get(0).elementType(), i, matrices.size());
            IPoint offset = offsets.get(i);
            Matrix<? extends PArray> frame = matrices.get(i);
            pyramid.addImage(frame, offset.coord(0), offset.coord(1));
            count++;
            memory += Matrices.sizeOf(frame);
        }
        long t4 = System.nanoTime();
        LOGGER.config(String.format(Locale.US,
            "Number of partially available pyramid layers: %d, "
                + "cached %d rows (%d/%d hits/misses writing, %d/%d hits/misses reading), "
                + "%d extra tile scaling, %d partial tile scaling",
            pyramid.numberOfImmediatelyAvailableResolutions(),
            pyramid.currentTileRowCacheSize(),
            pyramid.cacheWriteHitCounter(), pyramid.cacheWriteMissCounter(),
            pyramid.cacheReadHitCounter(), pyramid.cacheReadMissCounter(),
            pyramid.extraTileScalingCounter(),
            pyramid.partialTileScalingCounter()
        ));
        pyramid.finish(arrayContext.part(0.9, 1.0));
        long t5 = System.nanoTime();
        PlanePyramidContainer result = new PlanePyramidContainer(context, pyramid);
        String msg = String.format(Locale.US,
            "%d frames stitched in %.5f s: "
                + "%.5f allocation, %.5f conversion of Image2D, %.5f stitching, %.5f finishing "
                + "(stitching/finishing include %.5f copying and %.5f scaling); "
                + "stitching speed %.5f MB/s (without finishing %.5f MB/s, "
                + "copying %.5f MB/s, scaling %.5f MB/s), "
                + "cached %d rows (%d/%d hits/misses writing, %d/%d hits/misses reading), "
                + "%d extra tile scaling, %d partial tile scaling",
            count, (t5 - t1) * 1e-9,
            (t2 - t1) * 1e-9, (t3 - t2) * 1e-9, (t4 - t3) * 1e-9, (t5 - t4) * 1e-9,
            pyramid.copyingToZeroLevelTime() * 1e-9, pyramid.scalingTime() * 1e-9,
            memory / 1048576.0 / ((t5 - t3) * 1e-9), memory / 1048576.0 / ((t4 - t3) * 1e-9),
            memory / 1048576.0 / (pyramid.copyingToZeroLevelTime() * 1e-9),
            memory / 1048576.0 / (pyramid.scalingTime() * 1e-9),
            pyramid.currentTileRowCacheSize(),
            pyramid.cacheWriteHitCounter(), pyramid.cacheWriteMissCounter(),
            pyramid.cacheReadHitCounter(), pyramid.cacheReadMissCounter(),
            pyramid.extraTileScalingCounter(),
            pyramid.partialTileScalingCounter()
        );
        if (Arrays.SystemSettings.profilingMode()) {
            if (context.is(StatusUpdater.class)) {
                context.as(StatusUpdater.class).updateStatus(msg);
            }
        }
        LOGGER.config(msg);
        result.toPlanePyramid(); // for additional testing
        return result;
    }

    public static Image2D getImage(
        Context context,
        @Name("pyramid") PlanePyramidContainer pyramid,
        @Name("fromX") long fromX,
        @Name("fromY") long fromY,
        @Name("toX") long toX,
        @Name("toY") long toY,
        @Name("compression") double compression)
        throws JSONException
    {
        PlanePyramid planePyramid = pyramid.toPlanePyramid(context);
        Image2D result = PlanePyramidStitcher.getImage(context, planePyramid, fromX, fromY, toX, toY, compression);
        planePyramid.freeResources(PlanePyramidSource.FlushMethod.STANDARD);
        return result;
    }

    public static Image2D getImage(
            Context context,
            @Name("pyramidDataFile") com.simagis.files.DataFile pyramidFile,
            @Name("fromX") long fromX,
            @Name("fromY") long fromY,
            @Name("toX") long toX,
            @Name("toY") long toY,
            @Name("compression") double compression,
            @Name("mode") @UI(category = "text") String mode)
            throws IOException, JSONException
    {
        final String pyramidDirectory = pyramidFile.getPath().getAbsolutePath();
        return getImage(context, pyramidDirectory, fromX, fromY, toX, toY, compression, mode);
    }

    public static Image2D getImage(
        Context context,
        @Name("pyramidDirectory") String pyramidDirectory,
        @Name("fromX") long fromX,
        @Name("fromY") long fromY,
        @Name("toX") long toX,
        @Name("toY") long toY,
        @Name("compression") double compression,
        @Name("mode") @UI(category = "text") String mode)
        throws IOException, JSONException
    {
        if (mode == null) {
            mode = "";
        }
        JSONObject modeJson;
        try {
            modeJson = new JSONObject(mode);
        } catch (JSONException e) {
            modeJson = new JSONObject();
        }
        PlanePyramid p = PlanePyramidStitcher.getPyramid(null, pyramidDirectory, mode);
        if (toX == 0) {
            toX = p.dimX();
        }
        if (toY == 0) {
            toY = p.dimY();
        }
        Image2D result = PlanePyramidStitcher.getImage(context, p, fromX, fromY, toX, toY, compression);
        final int repeatCount = modeJson.optInt("repeatCount", 1);
        if (repeatCount > 1) { // for debugging caching and memory leak
            for (int k = 1; k < repeatCount; k++) {
                System.out.printf("%nRepeated reading %d...%n", k);
//            pyramid.freeResources(PlanePyramidSource.FlushMethod.STANDARD);
                result = PlanePyramidStitcher.getImage(context, p, fromX, fromY, toX, toY, compression);
            }
        }
        p.freeResources(PlanePyramidSource.FlushMethod.STANDARD);
        return result;
    }

    public static Image2D getBufferedImage(
        Context context,
        @Name("pyramid") PlanePyramidContainer pyramid,
        @Name("fromX") long fromX,
        @Name("fromY") long fromY,
        @Name("toX") long toX,
        @Name("toY") long toY,
        @Name("compression") double compression,
        @Name("mode") @UI(category = "text") String mode,
        @Name("backgroundColor") String backgroundColor,
        @Name("pathToSaveImage") String pathToSaveImage) throws JSONException, IOException
    {
        PlanePyramid p = pyramid.toPlanePyramid(context);
        if (toX == 0) {
            toX = p.dimX();
        }
        if (toY == 0) {
            toY = p.dimY();
        }
        return getBufferedImage(context, p,
            fromX, fromY, toX, toY, compression, mode == null ? "" : mode, backgroundColor, pathToSaveImage);
    }

    public static Image2D getBufferedImage(
        Context context,
        @Name("pyramidDirectory") String pyramidDirectory,
        @Name("fromX") long fromX,
        @Name("fromY") long fromY,
        @Name("toX") long toX,
        @Name("toY") long toY,
        @Name("compression") double compression,
        @Name("mode") @UI(category = "text") String mode,
        @Name("backgroundColor") String backgroundColor,
        @Name("pathToSaveImage") String pathToSaveImage) throws JSONException, IOException
    {
        if (mode == null) {
            mode = "";
        }
        PlanePyramid p = PlanePyramidStitcher.getPyramid(null, pyramidDirectory, mode);
        if (toX == 0) {
            toX = p.dimX();
        }
        if (toY == 0) {
            toY = p.dimY();
        }
        Image2D result = getBufferedImage(context, p,
            fromX, fromY, toX, toY, compression, mode, backgroundColor, pathToSaveImage);
        p.freeResources(PlanePyramidSource.FlushMethod.STANDARD);
        return result;
    }

    public static String convertToPlanePyramid(
        Context context,
        @Name("pyramidDirectory") String pyramidDirectory,
        @Name("mode") @UI(category = "text") String mode,
        @Name("dirToSavePyramid") String dirToSavePyramid) throws JSONException, IOException
    {
        if (mode == null) {
            mode = "";
        }
        PlanePyramid p = PlanePyramidStitcher.getPyramid(
            new SubtaskContext(context, 0.0, 0.5),
            pyramidDirectory, mode);
        DefaultPlanePyramidIO.sharePlanePyramid(
            new DefaultArrayContext(new SubtaskContext(context, 0.5, 1.0)),
            new File(dirToSavePyramid), p);
        return dirToSavePyramid;
    }



    // This method, as plugin function, works incorrectly under SIMAGIS
    public static PlanePyramidContainer openPyramidWithoutContext(
        @Name("directory") String directory)
        throws IOException
    {
        return PlanePyramidContainer.open(null, new File(directory));
    }

    private static Image2D getBufferedImage(
        Context context,
        PlanePyramid pyramid,
        long fromX,
        long fromY,
        long toX,
        long toY,
        double compression,
        String mode,
        String backgroundColor,
        String pathToSaveImage) throws JSONException, IOException
    {
        ArrayContext ac = new DefaultArrayContext(context);
        if (backgroundColor == null) {
            throw new NullPointerException("Null background color");
        }
        PlanePyramid.ReadingImageSettings readingImageSettings = new PlanePyramid.ReadingImageSettings();
        JSONObject modeJson;
        try {
            modeJson = new JSONObject(mode);
        } catch (JSONException e) {
            modeJson = new JSONObject();
        }
        boolean addAlpha = mode.contains("alpha");
        boolean banded = mode.contains("banded");
        if (modeJson.has("borderWidth")) {
            readingImageSettings.setBorderWidth(modeJson.getInt("borderWidth"));
            readingImageSettings.setBorderColor(Color.decode(modeJson.optString("borderColor", "#80FFFF")));
        }
        if (modeJson.has("nullWhenBackground")) {
            readingImageSettings.setNullWhenBackgroundOnly(modeJson.getBoolean("nullWhenBackground"));
        }
        MatrixToBufferedImageConverter converter;
        if (banded) {
            converter = new MatrixToBufferedImageConverter.Packed3DToBandedRGB(addAlpha);
        } else {
            converter = new MatrixToBufferedImageConverter.Packed3DToPackedRGB(addAlpha);
        }
        boolean fullyFilled = pyramid.getNonFilledAreasInRectangle(fromX, fromY, toX, toY, 0).isEmpty();
        readingImageSettings.setBackgroundColor(
            pyramid.isRectangleReadyForImmediatelyAvailableResolutions(fromX, fromY, toX, toY) ?
                new Color(Long.decode(backgroundColor).intValue(), addAlpha || pyramid.bandCount() >= 4) :
                Color.RED
        );
        long t1 = System.nanoTime();
        BufferedImage bufferedImage = pyramid.readBufferedImage(
            ac, fromX, fromY, toX, toY, compression,
            converter, readingImageSettings);
        long t2 = System.nanoTime(), t2Repeated = t2;
        final int repeatCount = modeJson.optInt("repeatCount", 1);
        if (repeatCount > 1) { // for debugging caching and memory leak
            for (int k = 1; k < repeatCount; k++) {
                System.out.printf("%nRepeated reading %d...%n", k);
//            pyramid.freeResources(PlanePyramidSource.FlushMethod.STANDARD);
                bufferedImage = pyramid.readBufferedImage(
                    ac, fromX, fromY, toX, toY, compression,
                    converter, readingImageSettings);
            }
            t2Repeated = System.nanoTime();
        }
        List<Matrix<? extends PArray>> matrices = bufferedImage == null ? null :
            new SimpleColorImageFormatter().toImage(bufferedImage);
//        bufferedImage = converter.toBufferedImage(matrices.get(0)); // - little test for 2D case
//        matrices = new SimpleColorImageFormatter().toImage(bufferedImage);
        long t3 = System.nanoTime();
        if (pathToSaveImage != null && pathToSaveImage.length() > 0 && bufferedImage != null) {
            String formatName = ExternalAlgorithmCaller.getFileExtension(new File(pathToSaveImage));
            if (formatName == null) {
                throw new IllegalArgumentException("Cannot write image into a file without extension");
            }
//            System.out.println(".." + bufferedImage + "; "
//                + bufferedImage.getRaster().getNumBands() + ", " + bufferedImage.getRaster().getNumDataElements() + "; "
//                + converter + "; " + readingImageSettings);
            ImageIO.write(bufferedImage, formatName, new File(pathToSaveImage));

//            Matrix<? extends PArray> m;
//            m = new BufferedImageToMatrixConverter.ToPacked3D(true)
//                .setReadPixelValuesViaColorModel(true)
//                .setReadPixelValuesViaGraphics2D(true)
//                .toMatrix(bufferedImage);
//            matrices = ImageConversions.unpack2DBandsFromSequentialSamples(null, m);
//            bufferedImage = new SimpleColorImageFormatter().toBufferedImage(matrices);
//            bufferedImage = ImageIO.read(new File(pathToSaveImage)); // - may change results for gray!
//            m = new BufferedImageToMatrixConverter.ToPacked3D(true)
//                .setReadPixelValuesViaColorModel(true)
//                .setReadPixelValuesViaGraphics2D(true)
//                .toMatrix(bufferedImage);
//            matrices = ImageConversions.unpack2DBandsFromSequentialSamples(null, m);
//            ImageIO.write(bufferedImage, formatName, new File(pathToSaveImage));
        }
        long t4 = System.nanoTime();
        Image2D result = bufferedImage == null ? null : context.as(ImageContext.class).newImage2D(context, matrices);
        long t5 = System.nanoTime();
        String msg = String.format(Locale.US,
            "BufferedImage loaded "
                + (fullyFilled ? "(fully the source data)" : "with drawing background")
                + ", %d bands in pyramid, %d matrices in Image2D in %.6f ms"
                + (repeatCount > 1 ? " / repeatedly " + (t2Repeated - t2) * 1e-6 / (repeatCount - 1) + " ms" : "")
                + " (+%.3f conversion into Image2D, +%.3f for writing file, "
                + "+%.3f for saving results); reading speed %.5f MB/s",
            pyramid.bandCount(),
            bufferedImage == null ? 0 : matrices.size(),
            (t2 - t1) * 1e-6, (t3 - t2Repeated) * 1e-6, (t4 - t3) * 1e-6, (t5 - t4) * 1e-6,
            bufferedImage == null ? 0 : Matrices.sizeOf(matrices) / 1048576.0 / ((t2Repeated - t1) * 1e-9)
        );
        if (Arrays.SystemSettings.profilingMode()) {
            if (context.is(StatusUpdater.class)) {
                context.as(StatusUpdater.class).updateStatus(msg);
            }
        }
        LOGGER.config(msg);
        return result;
    }

}
